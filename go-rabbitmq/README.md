### GO 操作RabbitMQ
目录结构
~~~
go-rabbitmq //go操作rabbitmq
├── r1_simple_work_queue    // 简单工作队列
│       ├── send // 生产者
│       └── work // 消费者
├── r2_work_queue    // 工作队列
│       ├── send // 生产者
│       └── work // 消费者
├── r3_publish_subsrcibe   // 发布/订阅模式
│       ├── publish // 发布者
│       └── subsrcibe // 订阅者
├── r4_route    // 路由模式
│       ├── send // 生产者
│       └── work // 消费者
├── r5_topic    // 主题模式
│       ├── send // 生产者
│       └── work // 消费者
├── r6_rpc    // rpc模式
│       ├── send // 生产者
│       └── work // 消费者
└── ~~~
~~~
### RabbitMQ 的作用
RabbitMQ 是一个开源的消息代理（Message Broker），用于在分布式系统中管理和传递消息。它主要用来在不同的应用程序或服务之间传递消息，使得这些应用程序或服务可以解耦、异步通信。RabbitMQ 使用高级消息队列协议（AMQP），支持多种消息传递模式，如发布/订阅、路由、主题、和工作队列等。

### RabbitMQ 的主要作用包括：

1. **消息传递**：
    - RabbitMQ 充当消息中介，将消息从生产者传递到消费者。它可以确保消息的可靠传输，即使接收者临时不可用，消息也能被妥善保存，等待消费。
2. **异步处理**：
    - 通过 RabbitMQ，应用程序可以将任务放入队列中，随后由一个或多个消费者异步处理。这种机制非常适合耗时较长的操作，如数据处理、文件转换等。
3. **系统解耦**：
    - RabbitMQ 使得生产者和消费者之间可以解耦。生产者只负责发送消息，而不关心消息的处理逻辑，消费者则可以独立地处理这些消息。
4. **负载均衡**：
    - RabbitMQ 支持多消费者的负载均衡模式，即同一个队列中的消息可以被多个消费者处理，从而实现任务的并行处理和系统的负载均衡。
5. **消息路由**：
    - RabbitMQ 提供了多种路由机制，通过不同类型的交换机（如 direct、fanout、topic、headers）将消息路由到合适的队列中，满足复杂的消息分发需求。

### RabbitMQ 的优势

1. **高可用性和可靠性**：
    - RabbitMQ 支持持久化、镜像队列等机制，确保消息在系统故障或崩溃时不丢失，增强了消息传递的可靠性。
2. **丰富的功能和灵活性**：
    - RabbitMQ 提供了多种消息传递模式和高级特性，如消息确认、延迟队列、死信队列等，可以满足各种应用场景的需求。
3. **可扩展性**：
    - RabbitMQ 可以通过集群、分片和高可用性配置扩展其处理能力，支持从单节点到分布式集群的灵活部署，以满足不同规模的应用需求。
4. **多语言支持**：
    - RabbitMQ 支持多种编程语言，如 Go、Java、Python、Ruby、C# 等，使得它能够轻松集成到各种技术栈中。
5. **社区支持和插件系统**：
    - 作为一个成熟的开源项目，RabbitMQ 拥有活跃的社区支持，并提供丰富的插件来扩展其功能，如集成监控、管理 UI、流量控制等。
6. **跨平台支持**：
    - RabbitMQ 可以部署在各种操作系统上，如 Linux、Windows、macOS，同时支持在云环境中运行，如 AWS、Azure、Google Cloud 等。

### 典型使用场景

- **异步任务处理**：如电子邮件发送、图像处理、视频转换等后台任务。
- **微服务间通信**：在微服务架构中，RabbitMQ 可用于不同服务之间的事件通知和数据传输。
- **事件驱动架构**：通过 RabbitMQ，可以实现复杂的事件驱动系统，支持事件的广播和处理。
- **日志收集**：集中收集和处理分布式系统中的日志信息。
- **实时消息传递**：如即时消息应用、在线交易系统中的订单处理。

总之，RabbitMQ 通过提供高效的消息传递机制，为分布式系统的构建和优化提供了强大的支持。